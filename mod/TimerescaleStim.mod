COMMENT

Modification by Johannes Luthman of the built-in NetStim.mod of NEURON 6.1.
NB, this code has not been used with CVode.

Changes from NetStim:
    The output events can be set to follow gamma distributions of order 1-6,
    where 1 corresponds to the original Poisson process generated by NetStim.mod.
    The gamma process is generated in the same way as that given by timetable.c
    in GENESIS 2.3.
    A refractory period has been added.
    The output length is determined by duration in ms instead of number of events.

Parameters:
    interval: 	mean time between spikes (ms)
    start:      start of first spike (ms)
    noise:      amount of randomness in the spike train [0-1], where 0 generates
                fully regular spiking with isi given by parameter interval.
    duration:   length in ms of the spike train.
    refractoryPeriod (ms)

ENDCOMMENT

NEURON  {
    ARTIFICIAL_CELL pfTimeresStim
    RANGE interval, start, duration, order, noise, refractoryPeriod
	RANGE amp,i,freq,phase,pi,st,y,r
}

PARAMETER {
	y=0   (ms)
    interval = 0 (ms) <1e-9,1e9>	: time between spikes (msec)
    start = 0 (ms)       		    : start of first spike
    noise = 0.4 <0,1>       		    : amount of randomness (0.0 - 1.0) in spike timing.
    duration = 1000 (ms)		    : input duration
    refractoryPeriod = 0 (ms)
	amp (nA)
	freq=0.001
	phase=0
	pi=3.1415926535 (pion)
	st=0.025 (ms)                  :step time 
	fla=1 <0,1e9>
	r=0 
}

ASSIGNED {
    event (ms)
    on
    end (ms)
}

PROCEDURE seed(x) {
    set_seed(x) : Calling .seed() from hoc affects the event streams
                : generated by all NetStims, see http://www.neuron.yale.edu/phpBB2/viewtopic.php?p=3285&sid=511cb3101cc8f4c12d47299198ed40c2
}

INITIAL {
	fla=1
	r=0
    on = 0 : off
    if (noise < 0) {
        noise = 0
    }
    if (noise > 1) {
        noise = 1
    }
    if (start >= 0) {
        : randomize the first spike so on average it occurs at
        : start + noise*interval
        event = start + invl(interval) - interval*(1. - noise)
        : but not earlier than 0
        if (event < 0) {
            event = 0
        }
		:printf("%gevent\n",event)
        net_send(event, 3)
    }
}

PROCEDURE init_sequence(t(ms)) {
    on = 1
    event = t
    end = t + 1e-6 + duration
}

FUNCTION invl(mean (ms)) (ms) {

    : This function returns spiking interval

    if (mean <= 0.) {
        mean = .01 (ms)
    }
    
      invl = (1. - noise)*ISItimes()+refractoryPeriod
		
}

PROCEDURE event_time() {
    event = event+invl(interval)
    if (event > end) {
        on = 0
    }
}

NET_RECEIVE (w) {
    if (flag == 0) { : external event
        if (w > 0 && on == 0) { : turn on spike sequence
            init_sequence(t)
            net_send(0, 1): net_send args: duration of event, flag to a NET_RECEIVE block,
                    : see The NEURON book ch 10 p343
        }else if (w < 0 && on == 1) { : turn off spiking
            on = 0
        }
    }
    if (flag == 3) { : from INITIAL
        if (on == 0) {
            init_sequence(t)
            net_send(0, 1)
        }
    }
    if (flag == 1 && on == 1) {	
		:printf("%gtt\n",t)	
		net_event(t) : See NEURON book p. 345. Sum: net_event tells NetCon something has happened.
        event_time()
        if (on == 1) {
        net_send(event-t, 1)
        }
        net_send(.1, 2)
    }
}


FUNCTION ISItimes() {	
	LOCAL x,z
	z=0
	while(z==0){
	r=amp*(cos(phase)-cos(2*pi*freq*st+phase))/(4*pi*freq)+amp*st/2
	:printf("%g %g %gbijiao\n",r,fla,st)
	if(r>=fla){
		if(fla==1){
			:printf("%gst",st)
			y=st
			fla=fla+1
			ISItimes=y
			z=1
		}else{
			:printf(" %g yy\n",y)
			ISItimes=st-y
			:printf(" %g ISI\n",ISItimes)
			y=st
			fla=fla+1
			z=1
		}
	
	}else{
		st=st+0.025
	}
	}
	:printf("%grr\n",r)
	z=0
	
}
